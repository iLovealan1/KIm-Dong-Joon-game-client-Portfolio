![header](https://capsule-render.vercel.app/api?type=waving&color=gradient&height=250&section=header&text=Luna%20Playable%20Games&fontSize=35)<br>

# 소개
안녕하세요. 플레이어블게임 포트폴리오에 오신걸 환영합니다.

- 저는 슈퍼센트 주식회사에서 3개월간 인턴으로 근무하며 루나플레이어블 플랫폼 게임을 개발하는 업무를 담당하였습니다.<br>
- 전체 개발을 담당한 게임 2개와 리펙토링에 참여한 게임 1개가 있습니다.<br>
- 전체 개발을 담당한 플레이어블게임들은 슈퍼센트 주식회사의 모바일 플랫폼 아케이드 아이들 장르의 게임인 Burger Please! 와 Outlet Rush의 미니게임들입니다.<br>
- 두개의 게임 모두 현재 전면광고 게임으로 현재 ironSource, Applovin, Lunaplayable 등의 플랫폼에서 배포되어 서비스 중입니다.<br>

아래는 개발한 게임 2개의 기술 목록입니다.

# Contacts
📧: 이메일 :  korindj@kakao.com<br>
🏠: 개발자 블로그 : [Blog Link](https://bueong-e.tistory.com)

# 목차

개요 : [📚:설명보기](#playableGame)<br>
게임소개 및 플레이링크 : [📚:설명보기](#IntroDuction)<br>

:red_circle: A*알고리즘을 활용한 절차적 랜덤 맵 생성 스크립트 제작.[📚:설명보기](#astar_random_map_generator) [📜:스크립트 보기](https://github.com/iLovealan1/KIm-Dong-Joon-game-client-Portfolio/tree/main/Scripts/Astar_MapGenerator)<br>

* * *


# 개요
### playableGame

![GraphicImage](https://docs.lunalabs.io/assets/lpp-overview.png)
🌕 Luna playable : [Docs Link][Luna playable Link]

[Luna playable Link]: https://docs.lunalabs.io/docs/playable/overview

▶️ 플레이어블 게임?
- 루나 플레이어블 플랫폼을 기반으로 제작된 전면광고용 미니 게임입니다.
- 현 라이브 서비스중인 게임의 홍보를 위해 제작되는 게임으로 모태가 되는 게임의 미니 게임입니다.

# **게임소개 및 플레이링크**<br>

### IntroDuction

*하단에 소개된 게임들은 전면 광고 게임으로 웹상에서 자바스크립트로 변환되어 플레이되기 때문에 게임소개 및 플레이링크 항목의 링크에서 플레이가 가능합니다.<br>
*사용중인 브라우저에서 플레이 불가능시 다른 인터넷 브라우저로 플레이 가능합니다.<br>
*게임 시작을 위해 클릭시 인게임 사운드가 재생됩니다.<br>
*웹상에서 플레이시 모바일로 플레이할때와 다르게 그래픽 오류등이 있을수 있습니다.

---

## 🎮: 게임소개

![스크린샷 2023-12-04 오후 5 35 46](https://github.com/iLovealan1/KIm-Dong-Joon-game-client-Portfolio/assets/124248265/a6c7d2b3-d5b0-4ba2-a261-976342089a92)
- **제목** : Outlet Rush Playable <br> 
- **장르** : Arcade Idle <br>
- **엔진** : UnityEngine3D<br>
- **플랫폼** : Luna Playable<br>
- **Impressions (실제 게임 플레이에 기반하는 게임 노출도)** : 2천 3백만회 이상<br>

## ⭐: 게임의 특징

*해당 게임은 기획단계부터 참여하여 전체를 제작한 프로젝트입니다.*
- 신발 과 옷등 아울렛을 운영하며 확장하는 아케이드 아이들 장르의 게임
- 유명 브랜드 신발과 옷을 판매하며 매대를 확장하고 직원을 고용하며 돈을 모아 가게를 확장하는 플로우
- 돈을 모아 최종 언락인 옷 매대 언락을하게 되면 게임이 끝나는 방식

👉 신발 혹은 옷 등을 손 위에 쌓고 매대로 옮겨지는 중독성 있는 애니메이션 <br>
👉 등뒤에 쌓이는 돈을 통해 돈을 모으는 재미를 시각적으로 표현<br>
👉 신발 -> 옷 순으로 언락되며 판매 품목이 많아지고 가게가 확장되는 것을 보는 재미<br>

## 🎲: 플레이 링크

👟: Outlet Rrush : [Link_Stack_ver][OutletRush 002]

[OutletRush 002]: https://playground.lunalabs.io/preview/117526/165584/1703aff40e6d4548f15efe206918c6945f053e4a8bd126710bf82d53d1925cc4


👟: Outlet Rrush : [Link_none_Stack_ver][OutletRush 002_none Stack]

[OutletRush 002_none Stack]: https://playground.lunalabs.io/preview/117526/165586/1703aff40e6d4548f15efe206918c6945f053e4a8bd126710bf82d53d1925cc4

---

## 🎮: 게임소개

![GraphicImage](https://private-user-images.githubusercontent.com/124248265/287611325-0df14cc0-d948-40fb-9a3e-2119cb44b2bb.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTEiLCJleHAiOjE3MDE2NzI1ODgsIm5iZiI6MTcwMTY3MjI4OCwicGF0aCI6Ii8xMjQyNDgyNjUvMjg3NjExMzI1LTBkZjE0Y2MwLWQ5NDgtNDBmYi05YTNlLTIxMTljYjQ0YjJiYi5wbmc_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBSVdOSllBWDRDU1ZFSDUzQSUyRjIwMjMxMjA0JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDIzMTIwNFQwNjQ0NDhaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT03MTNjNzBlNmNmYmQ3NDc2Yjk2ZWJmZWUzYTFhMTU5NmZjMzhlMTFlMWYxYTQ5M2RmZjRkNTQzYjcyOGRhZWU1JlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCZhY3Rvcl9pZD0wJmtleV9pZD0wJnJlcG9faWQ9MCJ9.Wq9GLm8RpAp4ypbClIomX2GwZJD7u-0u12uOk2cl_Lw)
- **제목** : Burger Please! Playable <br> 
- **장르** : Upgrade Idle <br>
- **엔진** : UnityEngine3D<br>
- **플랫폼** : Luna Playable<br>
- **Impressions (실제 게임 플레이에 기반하는 게임 노출도)** : 70만회 이상<br>

## ⭐: 게임의 특징

*해당 게임은 기획단계부터 참여하여 전체를 제작한 프로젝트입니다.*
- 주문을 위한 카운터, 버거 픽업을 위한 픽업대 구성의 업그레이드 아이들 게임
- 버거를 수령한 손님에게서 돈을 수금하여 카운터와 픽업대를 늘려나가는것이 게임의 주요 목표
- 게임의 마지막 언락 요소인 새로운 머신 추가시 게임이 끝나는 방식<br>

👉 버거를 주문하고 받아가기위해 분주하게 움직이는 손님들을 보는 재미요소<br>
👉 돈을 모아 가게를 확장해 가는 재미요소


## 🎲: 플레이 링크
🍔: Burger Please! Playable : [Link][Burger Please! 010]

[Burger Please! 010]: https://playground.lunalabs.io/preview/110188/155622/1703aff40e6d4548f15efe206918c6945f053e4a8bd126710bf82d53d1925cc4

---

## 🎮: 게임소개

![스크린샷 2023-12-04 오후 5 31 02](https://github.com/iLovealan1/KIm-Dong-Joon-game-client-Portfolio/assets/124248265/ae917819-e9de-4262-aee0-e8f85bb8255b)

- **제목** : Burger Please! Playable2 <br> 
- **장르** : Arcade Idle <br>
- **엔진** : UnityEngine3D<br>
- **플랫폼** : Luna Playable<br>
- **Impressions (실제 게임 플레이에 기반하는 게임 노출도)** : 3천만회 이상<br>

## ⭐: 게임의 특징

*해당게임은 기존 라이브 서비스중이던 프로젝트에 버거머신 단계 추가, 맵 오브젝트 재배치, 버그수정등 리펙토링에 참여한 프로젝트입니다.*
- 버거머신에서 버거를 수령해 손님에게 팔아 가게를 확장하는 아케이드 아이들 장르의 게임
- 총 3단계의 버거 머신 업그레이드와 드라이브스루 파트로의 확장, 카운터 직원 고용이 게임의 핵심요소
- 돈을 모아 마지막 확장요소인 가게 크기 확장을 하면 게임이 끝나는 방식


👉 버거를 손 위에 쌓아 카운터로 전달하는 중독성 있는 애니메이션<br>
👉 업그레이드된 버거머신으로 부터 나오는 버거의 진화버전을 보는 재미<br>
👉 드라이브 스루 언락으로 인해 혼자 담당하기 힘들어진 가게를 직원 고용을 통해 해소하여 몰입감을 선사<br>

## 🎲: 플레이 링크
🍔: Burger Please! Playable 2 : [Link][Burger Please! 011]

[Burger Please! 011]: 
https://playground.lunalabs.io/preview/113799/160490/1703aff40e6d4548f15efe206918c6945f053e4a8bd126710bf82d53d1925cc4

---

# 제작 스크립트 설명

## 🟢: Outlet Rrush Playable<br>[📂:폴더이동](https://github.com/iLovealan1/KIm-Dong-Joon-game-client-Portfolio/tree/main/PlayableGames_Scripts/OutletRush_Playable)

### 🔖: player control & camera control

![player controll & camera control](https://private-user-images.githubusercontent.com/124248265/287693313-86f36534-7d34-44dd-bf27-7f0af1011849.gif?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTEiLCJleHAiOjE3MDE3NTY0OTcsIm5iZiI6MTcwMTc1NjE5NywicGF0aCI6Ii8xMjQyNDgyNjUvMjg3NjkzMzEzLTg2ZjM2NTM0LTdkMzQtNDRkZC1iZjI3LTdmMGFmMTAxMTg0OS5naWY_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBSVdOSllBWDRDU1ZFSDUzQSUyRjIwMjMxMjA1JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDIzMTIwNVQwNjAzMTdaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT0wNGMxNGIwN2Y0NjI1OGFjZGRhZmY5YWQ3YzkxZmI0Yzc4MDNmNDQ3NDA1MzZmNGUwM2U1NzE1YTdmZDJjYjNmJlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCZhY3Rvcl9pZD0wJmtleV9pZD0wJnJlcG9faWQ9MCJ9.2X6glU0emHiplsaoiiLSldT7-SpTG08hWYLv2V0CWgM)
![player controll & camera control](https://private-user-images.githubusercontent.com/124248265/287710384-324c3364-2b2a-4832-b147-dbb0f0c62b6b.gif?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTEiLCJleHAiOjE3MDE3NTY0OTcsIm5iZiI6MTcwMTc1NjE5NywicGF0aCI6Ii8xMjQyNDgyNjUvMjg3NzEwMzg0LTMyNGMzMzY0LTJiMmEtNDgzMi1iMTQ3LWRiYjBmMGM2MmI2Yi5naWY_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBSVdOSllBWDRDU1ZFSDUzQSUyRjIwMjMxMjA1JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDIzMTIwNVQwNjAzMTdaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT0wZjEzZmFhMGE2MjM4ZjUxMDA0OWQ4YTUzZTQ4ZGU1MWE3MDdkZDhhOGI0ZTY3ZjYyZDU1MWFjZTk2NDRiMTliJlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCZhY3Rvcl9pZD0wJmtleV9pZD0wJnJlcG9faWQ9MCJ9.LxAy75St3SkOqnhnLfWpjXGJwSoNXO84PzosaCdZfEs)

### **이미지 설명(좌측부터)**
- 가상 조이스틱을 이용한 플레이어의 움직임을 볼 수 있습니다.
- 플레이어를 따라다니는 카메라의 움직임을 볼 수 있습니다.
- 이벤트 발생시 카메라의 움직임을 볼 수 있습니다.

### **요약**
- Joystick UI 객체와 MainCamer 객체는 플레이어와 Interface를 통해 소통하여 객체 은닉화.
- Event System을 통한 IPlayerMoveHandler 메서드 호출로 인터페이스에 플레이어의 움직임을 위임
- IPositionReturner 인터페이스의 GetPosition() 메서드를 통한 플레이어의 현재 포지션 값을 카메라에 전달
- IPlayerMoveHandler, IPositionReturner 간의 인터페이스 상속으로 카메라 이벤트 호출시 다운캐스팅을 통해 플레이어의 움직임 제어
- 내부 서브모듈 TWeen 유틸과 Ease 유틸을 활용한 카메라 이벤트 움직임

### **관련 스크립트**

**IPlayerMoveHandler**[📜 : 스크립트 전문보기](https://github.com/iLovealan1/KIm-Dong-Joon-game-client-Portfolio/blob/main/PlayableGames_Scripts/OutletRush_Playable/InterFaces/IPlayerMoveHandler.cs)<br>
**IPositionReturner**[📜 : 스크립트 전문보기](https://github.com/iLovealan1/KIm-Dong-Joon-game-client-Portfolio/blob/main/PlayableGames_Scripts/OutletRush_Playable/InterFaces/IPositionReturner.cs)<br>
**Player**[📜 : 스크립트 전문보기](https://github.com/iLovealan1/KIm-Dong-Joon-game-client-Portfolio/blob/main/PlayableGames_Scripts/OutletRush_Playable/Unit/Player.cs)<br>
###코드

&nbsp;&nbsp;&nbsp;&nbsp;● MovePlayer() : 플레이어의 이동 로직 메서드입니다.<br>

````
public void MovePlayer(float vertical ,float horizontal) // 잔딜받은 float 값을 통한 플레이어 제어
{
    if (IsOKToMove == false) // 카메라 이벤트 시작시 플레이어 움직임 제한
    {
        _rigedBody.velocity = Vector3.zero;
        ChangeAnimation(true);
        return;
    }
    
    if (vertical == 0 && horizontal == 0)
    {
        _rigedBody.velocity = Vector3.zero;
        ChangeAnimation(true);
        return;
    }
    
    Vector3 targetDirection = _cameraForward * vertical + _cameraRight * horizontal;
    targetDirection.Normalize();
    
    if (targetDirection != Vector3.zero)
    {
        Quaternion targetRotation = Quaternion.LookRotation(targetDirection, Vector3.up);
        this.transform.rotation = Quaternion.Slerp(this.transform.rotation, targetRotation, _rotationSpeed);
    }
    
    ChangeAnimation(false);
    _rigedBody.velocity = targetDirection * _speed;
}
````

**VJHandler**[📜 : 스크립트 전문보기](https://github.com/iLovealan1/KIm-Dong-Joon-game-client-Portfolio/blob/main/PlayableGames_Scripts/OutletRush_Playable/UI/VJHandler.cs)<br>
###코드

&nbsp;&nbsp;&nbsp;&nbsp;● OnDrag() : 이벤트 시스템을  MovePlayer() 메서드를 호출합니다. .<br>

````
 public void OnDrag(PointerEventData ped)
{
    Vector2 position = Vector2.zero;

    ScreenPointToLocalPointInRectangle
            (_jsContainer.rectTransform,
            ped.position,
            ped.pressEventCamera,
            out position);

    position.x = (position.x / _jsContainer.rectTransform.sizeDelta.x);
    position.y = (position.y / _jsContainer.rectTransform.sizeDelta.y);

    float x = (_jsContainer.rectTransform.pivot.x == 1f) ? position.x : position.x;
    float y = (_jsContainer.rectTransform.pivot.y == 1f) ? position.y : position.y;

    InputDirection = new Vector3(x, y, 0);
    InputDirection = (InputDirection.magnitude > 1) ? InputDirection.normalized : InputDirection;

    _joystick.rectTransform.anchoredPosition = new Vector3(InputDirection.x * (_jsContainer.rectTransform.sizeDelta.x / 3)
                                                           , InputDirection.y * (_jsContainer.rectTransform.sizeDelta.y) / 3);
    if (Vector2.Distance(ped.position, ped.pressPosition) > moveThreshold)
    {
        _playerMoveHandler.MovePlayer(InputDirection.y, InputDirection.x);   // 플레이어 이동 인터페이스 위임                                        
    }
}

````

**PlayerCamera**[📜 : 스크립트 전문보기](https://github.com/iLovealan1/KIm-Dong-Joon-game-client-Portfolio/blob/main/PlayableGames_Scripts/OutletRush_Playable/ETC/PlayerCamera.cs)<br>
###코드

&nbsp;&nbsp;&nbsp;&nbsp;● GetPosition() : 플레이어의 위치를 받아오는 인터페이스 메서드입니다. LateUpdate에서 호출됩니다. <br>
&nbsp;&nbsp;&nbsp;&nbsp;● StartEventCamYoyo() : 카메라 이벤트 이동 메서드입니다. 이동은 Tween 유틸과 Ease 유틸을 활용하였습니다. <br>

````

private void LateUpdate()
{
    if (!_isEvnet)
    {
        _playerPos = _playerPosReturner.GetPosition();
        this.transform.position = _playerPos - _targetPos;
    }
}

public void StartEventCamYoyo(EEventCamType type)
{
    var moveHandler =_playerPosReturner as IPlayerMoveHandler; // 다운캐스팅을 통한 bool값 제어
    
    if ( moveHandler == null )
        return;

    if ( _eventCamToken.IsValid() )
        return;

    _isEvnet = true;
    moveHandler.IsOKToMove = false;

    var defaultPos = this.transform.position;
    var idx = (int)type;
    var targetTrans = _eventCamTransList[idx];

    var camMoveTimer = _camMoveTimer;
    var camComebackTimer = _camComeBackTimer;

    if (type == EEventCamType.DisplayCloathes)
    {
        camMoveTimer -= 0.2f;
        camComebackTimer -= 0.2f;
    }

    TweenUtil.TweenPosition(
        this.transform,
        targetTrans,
        new Params(TimeType.Scale)
        {    
            secDuration = camMoveTimer, 
            timeModular = (t) => EaseUtil.SineIn(t) 
        }, 
        (done_MoveIn) =>{

            var waitPos = new Vector3(
                this.transform.position.x, 
                this.transform.position.y + 0.0001f, 
                this.transform.position.z);

            TweenUtil.TweenPosition(
                this.transform,
                waitPos,
                false,
                _camWaitTimer,
                (done_Wait) =>{
                    TweenUtil.TweenPosition(
                    this.transform,
                    defaultPos,
                    new Params(TimeType.Scale)
                    {    
                        secDuration = camComebackTimer, 
                        timeModular = (t) => EaseUtil.SineIn(t) 
                    }, 
                    (done_MoveOut) =>{

                        if (_onFirstMoveEventDone != null)
                        {
                            _onFirstMoveEventDone.Invoke();
                            _onFirstMoveEventDone = null;
                        }

                        _isEvnet = false;
                        moveHandler.IsOKToMove = true;
                    });
            });
    });
}
````
[📑: 목차로](#목차)

### 🔖: Item Stacking

![item_stacking](https://private-user-images.githubusercontent.com/124248265/287960347-f75b00d7-2048-4805-bac4-a326c5044bca.gif?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTEiLCJleHAiOjE3MDE3NjIyMzgsIm5iZiI6MTcwMTc2MTkzOCwicGF0aCI6Ii8xMjQyNDgyNjUvMjg3OTYwMzQ3LWY3NWIwMGQ3LTIwNDgtNDgwNS1iYWM0LWEzMjZjNTA0NGJjYS5naWY_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBSVdOSllBWDRDU1ZFSDUzQSUyRjIwMjMxMjA1JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDIzMTIwNVQwNzM4NThaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT01YzQzYmY2MmQyYTc1Njc4OWFkMDQxODc4ZDZkN2VmOTBjODc4Y2EyNzk2ODJhY2JhNDI4MTlhMTgyOGYyMjBhJlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCZhY3Rvcl9pZD0wJmtleV9pZD0wJnJlcG9faWQ9MCJ9.22RB5d9wdW48g7et7kZUZUjZF66nCOYk8xrF9kCV--Y)![counter_item_stacking](https://private-user-images.githubusercontent.com/124248265/287960342-e5e8fa25-f841-45af-95ab-f95353ed781e.gif?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTEiLCJleHAiOjE3MDE3NjIyMzgsIm5iZiI6MTcwMTc2MTkzOCwicGF0aCI6Ii8xMjQyNDgyNjUvMjg3OTYwMzQyLWU1ZThmYTI1LWY4NDEtNDVhZi05NWFiLWY5NTM1M2VkNzgxZS5naWY_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBSVdOSllBWDRDU1ZFSDUzQSUyRjIwMjMxMjA1JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDIzMTIwNVQwNzM4NThaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT03YTE5MTI1YzU3ODRmMzViZDQxNTIxYTcwNTAzY2MwNTNjNjk5ZjIzYWUyOGUzYmJiODQzNzI2Zjk4M2YyMjZkJlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCZhY3Rvcl9pZD0wJmtleV9pZD0wJnJlcG9faWQ9MCJ9.-frpNdojiQ3rvs_2lkO2toRBVt1H0WJiJSfHVnX1LDM)![item_stacking_mixed](https://private-user-images.githubusercontent.com/124248265/287960308-6bfca6e4-bba7-48ce-9778-ddeefa50e0c9.gif?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTEiLCJleHAiOjE3MDE3NjIyMzgsIm5iZiI6MTcwMTc2MTkzOCwicGF0aCI6Ii8xMjQyNDgyNjUvMjg3OTYwMzA4LTZiZmNhNmU0LWJiYTctNDhjZS05Nzc4LWRkZWVmYTUwZTBjOS5naWY_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBSVdOSllBWDRDU1ZFSDUzQSUyRjIwMjMxMjA1JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDIzMTIwNVQwNzM4NThaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT00ODljODY2ZjJhMmY1MDgxMDUyNDRkMzhmMjk2ZGQ2MmRhMDJlYzFkMWFmYThiNzE2MGQwNWQ0YTZkZjBiZjVlJlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCZhY3Rvcl9pZD0wJmtleV9pZD0wJnJlcG9faWQ9MCJ9.lfBhTakjBdfYJ6-zgiVehVIkF3331yYTG4qj1t90FVY)
![item_stacking_2](https://private-user-images.githubusercontent.com/124248265/287960298-7cca91fd-baae-4d5d-b008-a65072be2548.gif?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTEiLCJleHAiOjE3MDE3NjIyMzgsIm5iZiI6MTcwMTc2MTkzOCwicGF0aCI6Ii8xMjQyNDgyNjUvMjg3OTYwMjk4LTdjY2E5MWZkLWJhYWUtNGQ1ZC1iMDA4LWE2NTA3MmJlMjU0OC5naWY_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBSVdOSllBWDRDU1ZFSDUzQSUyRjIwMjMxMjA1JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDIzMTIwNVQwNzM4NThaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT0xNmRkMzAwZDgyNTE0NDg0N2ExNjBjZDljMWY3OTc3YTYxMjVlNGM0N2Y0YWY1YTI0NzA4OGE0ZjBmM2JkZTFlJlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCZhY3Rvcl9pZD0wJmtleV9pZD0wJnJlcG9faWQ9MCJ9.qX9lOZ_moNE7HgBoq-4YEBRvcFPKeR5SFLHs2zSzTrQ)![item_stackpoint](https://private-user-images.githubusercontent.com/124248265/287960286-2cfae9ed-d92b-4b22-8659-479d42d0dfb8.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTEiLCJleHAiOjE3MDE3NjIyMzgsIm5iZiI6MTcwMTc2MTkzOCwicGF0aCI6Ii8xMjQyNDgyNjUvMjg3OTYwMjg2LTJjZmFlOWVkLWQ5MmItNGIyMi04NjU5LTQ3OWQ0MmQwZGZiOC5wbmc_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBSVdOSllBWDRDU1ZFSDUzQSUyRjIwMjMxMjA1JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDIzMTIwNVQwNzM4NThaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT00MDEyZWMwYTllZTk1OTc1NTk5ZWUxZTEwYzBjMmQ5YjY1ODZmMzZmMmZiYzI2ZWU2ODQ1MTFkYzZjOGE1Y2Y1JlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCZhY3Rvcl9pZD0wJmtleV9pZD0wJnJlcG9faWQ9MCJ9.lAgz8HpYSzo4jyYVFo7pxiy1KNvgR49bA8uBDjDUdwo)

### **이미지 설명(좌측 상단부터)**
- 플레이어가 창고매대에서 아이템을 스택 후 매장 시발매대에 디스플레잉 하는 모습입니다.
- 카운터에서 손님의 아이템을 픽업하여 포장후 다시 손님에게로 스택되는 모습입니다.
- 플레이어가 창고매대에서 옷과 신발을 섞어서 스택하는 모습입니다.
- 매장 옷매대에서 옷만을 골라 디스플레잉 하는 모습입니다.
- 플레이어의 손위 스택 포인트 기즈모를 확인할수 있습니다.
- 모든 객체와 상호작용시 객체 하단의 그림자 인터렉티브 에리어의 사이즈가 변경되는걸 확인할수 있습니다.


### **요약**
- 각 객체는 자신의 colider의 TriggerEnter() 메서드 호출로 레이어로 객체를 구분하여 그에 맞는 기능을 수행.
- 상호작용시 해당 클래스가 상속받은 인터페이스를 TryGetComponent로 null 체크를 수행한뒤 인터페이스의 기능을 호출.
- 아이템을 가지고 있을수 있는 객체들은 상황에 맞는 IItemListReturner,IDIsplayItemReturner,IBoxReturner 인터페이스를 상속하여 플레이어 혹은 손님 객체와 소통.
- 아이템 스택은 IItemListReturner로 Item 제너릭 리스트를 넘겨받아 자신의 리스트에 넣으며 애니메이션을 실행.
- 스택 완료시 함께 Out인자로 전달받은 done callback 을 스택이 마무리된 객체가 호출.
- 아이템 스택은 Lerp() 함수와 Animation Curve 클래스를 활용하여 연출.
- 자체 제작 오브젝트 Pool 클래스를 활용하여 메모리 부담을 덜 수 있게 활용.

### **관련 스크립트**
**IItemListReturner**[📜 : 스크립트 전문보기](https://github.com/iLovealan1/KIm-Dong-Joon-game-client-Portfolio/blob/main/PlayableGames_Scripts/OutletRush_Playable/InterFaces/IItemListReturner.cs)<br>
**IDIsplayItemReturner**[📜 : 스크립트 전문보기](https://github.com/iLovealan1/KIm-Dong-Joon-game-client-Portfolio/blob/main/PlayableGames_Scripts/OutletRush_Playable/InterFaces/IDIsplayItemReturner.cs)<br>
**IBoxReturner**[📜 : 스크립트 전문보기](https://github.com/iLovealan1/KIm-Dong-Joon-game-client-Portfolio/blob/main/PlayableGames_Scripts/OutletRush_Playable/InterFaces/IBoxReturner.cs)<br>
**ItemPool**[📜 : 스크립트 전문보기](https://github.com/iLovealan1/KIm-Dong-Joon-game-client-Portfolio/blob/main/PlayableGames_Scripts/OutletRush_Playable/Items/ItemPool.cs)<br>
**Player**[📜 : 스크립트 전문보기](https://github.com/iLovealan1/KIm-Dong-Joon-game-client-Portfolio/blob/main/PlayableGames_Scripts/OutletRush_Playable/Unit/Player.cs)<br>
### 코드

&nbsp;&nbsp;&nbsp;&nbsp;● TakeItems() : 플레이어가 성공적으로 매대의 인터페이스를 가져왔을떄 호출되는 메서드입니다. <br>
&nbsp;&nbsp;&nbsp;&nbsp;● CoJumpItem() : 플레이어의 아이템 획득 애니메이션 로직이 실행되는 유니티 코루틴입니다. <br>
&nbsp;&nbsp;&nbsp;&nbsp;● FindEmptyPoint() : 아이템을 스택할수 있는 빈 공간을 찾는 내부함수 입니다. <br>
````
protected override IEnumerator TakeItems(List<Item> takenItemList, Action doneCallback = null)
{
    _isCarrying = true;
    _isDuringStacking = true;
    var needAmount = _maxItemCarryAmount - _currItemList.Count;

    for (int i = 0; i < needAmount; i++)
    {
        var lasIdx = takenItemList.Count - 1; 
        var item = takenItemList[lasIdx]; //넘겨받은 아이템 리스트의 마지막 인덱스 요소
        takenItemList.Remove(item);
        _currItemList.Add(item);        //스택할 객체의 아이템 리스트에 넣기

        var isClothes = item is Clothes;   //is 연산자를 통해 item을 상속받은 Clothes 클래스인지 다운캐스팅 가능여부 확인

        if (i == needAmount - 1) //필요한 마지막 아이템인지 확인
        {
            this.StartCoroutine(CoJumpItem(item,isClothes,doneCallback)); 
        }
        else 
        {
            this.StartCoroutine(CoJumpItem(item,isClothes));
        }

        yield return CoroutineUtil.WaitForSeconds(_itemTakeTimeInterval); 
    }
}

private IEnumerator CoJumpItem(Item item, bool isClothes = false ,Action doneCallBack = null)
{
    var itemTrans = item.transform;
    itemTrans.parent = null;
    yield return null;

    var targetTrans = FindEmptyPoint(); //지역함수를 활용해 스택 가능한 위치 확인
    var startSec = Time.time;
    var endSec = startSec + _itemMoveTimeLimit;
    var startPos = itemTrans.position;

    AudioManager.NullableInstance.PlaySFX(EAudioName.StackSound, false, false,0.25f);

    while (Time.time < endSec) //Lerp() 함수를 활용하여 아이템 이동연출
    {
        var ratio = (Time.time - startSec) / _itemMoveTimeLimit;

        if (isClothes)
        {
            itemTrans.position = Vector3.Lerp(itemTrans.position, targetTrans.position, _itemMoveCurve.Evaluate(ratio));
        }
        else
        {
            itemTrans.position = Vector3.Lerp(itemTrans.position, targetTrans.position, _itemMoveCurve.Evaluate(ratio));
        }

        itemTrans.position = itemTrans.position + Vector3.up * _itemJumpCurve.Evaluate(ratio);
        yield return CoroutineUtil.WaitForFixedUpdate;
    }

    //...

    if (doneCallBack != null) // 마지막 아이템 이었다면 done Callback 호출
    {
        AudioManager.NullableInstance.ResetPitch(EAudioName.StackSound);
        doneCallBack.Invoke();
        _takeItemCorutine = null;
        _isDuringStacking = false;
    }

    Transform FindEmptyPoint() // 빈곳 할당을 위한 지역함수
    {
        Transform pointTrans = null;

        var idx = _currItemList.Count - 1;
        pointTrans = _stackPointList[idx];

        return pointTrans;
    }
}
````
**StorageShelf**[📜 : 스크립트 전문보기](https://github.com/iLovealan1/KIm-Dong-Joon-game-client-Portfolio/blob/main/PlayableGames_Scripts/OutletRush_Playable/Shelfs/StorageShelf.cs)<br>
### 코드

&nbsp;&nbsp;&nbsp;&nbsp;● GetItemList() : IItemListReturner를 상속받은 객체가 구현한 메서드로 자신의 상황에 따라 아이템리스트와 doneCallback을 out으로 반환합니다<br>

````
public List<Item> GetItemList(out Action doneCallBack)
{
    if (_isItemSpawning)
    {
        doneCallBack = null;
        return null;
    }
    else
    {
        if (_onPlayerTakeItems != null)
        {
            doneCallBack = () => {
                _onPlayerTakeItems.Invoke(EGuideArrowState.DisplayShelf_Shoe1_Take);
                _onPlayerTakeItems = null;
                GenerateItems();
            };
        }
        else
        {
            doneCallBack = GenerateItems;
        }
    
        return _currItemList;
    }
}                
````
**DisplayShelf**[📜 : 스크립트 전문보기](https://github.com/iLovealan1/KIm-Dong-Joon-game-client-Portfolio/blob/main/PlayableGames_Scripts/OutletRush_Playable/Shelfs/DisplayShelf.cs)<br>
### 코드

&nbsp;&nbsp;&nbsp;&nbsp;● OnTriggerEnter() : 콜라이더에 접근한 객체를 레이어로 확인하여 IItemListReturner 인터페이스의 GetItemList() 메서드를 호출합니다.<br>

````
private void OnTriggerEnter(Collider other) 
{
    var type = (ELayerName)other.gameObject.layer; 

    switch(type) // 레이어 구분
    {
        case ELayerName.Player :  
        {
            if (_type == EDisplayShelfType.Shoe_2 && _isPrepared == false)
                return;

            if (_takeItemCoroutine != null)
                return;
                
            if (_currItemList.Count == _pointList.Count)
                return;

            if (other.TryGetComponent<IItemListReturner>(out IItemListReturner returner)) //TryGetComponent를 통해 GetItemList() 메서드 호출 시도
            {
                var takenItemList = returner.GetItemList(out Action doneCallBack);

                 if (takenItemList == null)
                    return;

                if (!CheckItemList(_type, takenItemList, out int availAmount))
                    return;

                _takeItemCoroutine = this.StartCoroutine(TakeItems(takenItemList,availAmount,doneCallBack));
            }

            return;
        }

        case ELayerName.Customer :
        {
            if (_type == EDisplayShelfType.Clothes)
                return;

            _waitCustomerQueue.Enqueue(other);
            return;
        }
    }       
}        
````

[📑: 목차로](#목차)

### 🔖: Money Stacking

![item_stacking](https://private-user-images.githubusercontent.com/124248265/287960318-16f31a90-6565-47ed-93ea-4a5f79520465.gif?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTEiLCJleHAiOjE3MDE3NzE3NzQsIm5iZiI6MTcwMTc3MTQ3NCwicGF0aCI6Ii8xMjQyNDgyNjUvMjg3OTYwMzE4LTE2ZjMxYTkwLTY1NjUtNDdlZC05M2VhLTRhNWY3OTUyMDQ2NS5naWY_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBSVdOSllBWDRDU1ZFSDUzQSUyRjIwMjMxMjA1JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDIzMTIwNVQxMDE3NTRaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT00MjEyOTY1MDA5ZDZjODVkYjE5YjljYTRmNDU4ZGVlNzI2ZjRjYWZmOTRlODUyNzNkOGE2NDkzZDNhZDAwZWYwJlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCZhY3Rvcl9pZD0wJmtleV9pZD0wJnJlcG9faWQ9MCJ9.2-1DmEywPePdJt_bubIYAP158pJ9SPBsQpJhNkEoQ1E)![counter_item_stacking](https://private-user-images.githubusercontent.com/124248265/287960335-1b6b6330-2dce-4693-834e-1d7796a5c93b.gif?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTEiLCJleHAiOjE3MDE3NzE3NzQsIm5iZiI6MTcwMTc3MTQ3NCwicGF0aCI6Ii8xMjQyNDgyNjUvMjg3OTYwMzM1LTFiNmI2MzMwLTJkY2UtNDY5My04MzRlLTFkNzc5NmE1YzkzYi5naWY_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBSVdOSllBWDRDU1ZFSDUzQSUyRjIwMjMxMjA1JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDIzMTIwNVQxMDE3NTRaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT1lNTlhNWQ1ZTcxNDhkZjc5YjkzZTUwYzQ3MmQ5YTIxNjNjZTA2ODFlNjJjODA0ZDYyZmFjNjZjNmI1OWNjNDZjJlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCZhY3Rvcl9pZD0wJmtleV9pZD0wJnJlcG9faWQ9MCJ9.QwTyxouZaCdSkFc9ALdSnmrquPqmvOjVqPTJ13Wujho)

### **이미지 설명(좌측 상단부터)**
- 이번 프로젝트에서는 두가지 모드가 제작되었습니다. 하나는 돈이 등 뒤로 실물로 쌓이는 모드와 그렇지 않은 모드가 있습니다.
- 첫번째는 돈이 등 뒤로 쌓이는 모드의 모습을 볼수 있습니다.
- 두번째는 돈이 유저에게 흡수되는 모드의 모습을 볼수 있습니다.

### **요약**
- 아이템 스택과 동일하게 인터페이스로 소통하지만 IMoneyStackReturner 인터페이스로 제너릭 Stack을 이용해 Money 클래스 객체들을 저장.
- 플레이어 돈 스택킹의 경우 Lerp() 함수와 사내 Tween 유틸을 활용하여 돈 스택킹 애니메이션을 구현.
- 돈이 쌓이는 위치에는 Transform 배열을 활용하여 돈이 쌓이는 위치별 childCount 를 확인하여 구분하는 방식으로 돈 스택킹 구현. 
- 자체 제작 오브젝트 Pool 클래스를 활용하여 메모리 부담을 덜 수 있게 활용.
- 돈획득시 MoneyManager static 클래스를 통해 실제 유저의 금액을 증가시키고 static 클래스 내부에선 게임 Awake 단에서 할당된 이벤트를 호출합니다.
  

### **관련 스크립트**
**IMoneyStackReturner**[📜 : 스크립트 전문보기](https://github.com/iLovealan1/KIm-Dong-Joon-game-client-Portfolio/blob/main/PlayableGames_Scripts/OutletRush_Playable/InterFaces/IMoneyStackReturner.cs)<br>
**Money**[📜 : 스크립트 전문보기](https://github.com/iLovealan1/KIm-Dong-Joon-game-client-Portfolio/blob/main/PlayableGames_Scripts/OutletRush_Playable/MoneyObject/Money.cs)<br>
**MoneyManager**[📜 : 스크립트 전문보기](https://github.com/iLovealan1/KIm-Dong-Joon-game-client-Portfolio/blob/main/PlayableGames_Scripts/OutletRush_Playable/Managers/MoneyManager.cs)<br>
**Player**[📜 : 스크립트 전문보기](https://github.com/iLovealan1/KIm-Dong-Joon-game-client-Portfolio/blob/main/PlayableGames_Scripts/OutletRush_Playable/Unit/Player.cs)<br>
### 코드

&nbsp;&nbsp;&nbsp;&nbsp;● CoTakeMoney() : 플레이어가 성공적으로 인터페이스를 가져왔을떄 호출되는 메서드입니다. <br>
&nbsp;&nbsp;&nbsp;&nbsp;● JumpMoney() : Lerp() 함수와 TweenUtil을 활용하여 돈을 스택하는 애니메이션을 실행합니다. <br>

````
private IEnumerator CoTakeMoney(Stack<Money> takenMoneyStack , Action doneCallback)
{ 
    if (!IsMoneyStackingMode) // GameManager의 설정된 모드에 따라 기능 수행
        AudioManager.NullableInstance.PlaySFX(EAudioName.MoneyTakeSound,true);
   
    while(takenMoneyStack.Count > 0)
    {
        var money = takenMoneyStack.Pop(); // 가져온 스택에서 객체 pop
        _currMoneyStack.Push(money); pop으로 꺼낸 객체 저장 pop

        var cnt = _moneyStackPoint.childCount;
        var targetPos = _moneyStackInterval * cnt;

        if (IsMoneyStackingMode)
            money.transform.parent = _moneyStackPoint; 
        else 
            money.transform.parent = null;
        

        if (takenMoneyStack.Count == 0)
        {
            doneCallback.Invoke();

            if (IsMoneyStackingMode)
                this.StartCoroutine(JumpMoney(money,targetPos,doneCallback));
            else    
                this.StartCoroutine(CoJumpMoney_NoStackVer(money,doneCallback));
        }
        else
        {
           if (IsMoneyStackingMode)
                this.StartCoroutine(JumpMoney(money,targetPos));
            else    
                this.StartCoroutine(CoJumpMoney_NoStackVer(money));
        }

        yield return CoroutineUtil.WaitForSeconds(_moneyTakeInterval);
    }
}

private IEnumerator JumpMoney(Money money, Vector3 targetPos, Action doneCallback = null)
{
    var moneyTrans = money.transform;
    var startSec = Time.time;
    var endSec = startSec + _moneyMoveTimeLimit;
    Vector3 startPos = moneyTrans.localPosition;

    // 트윈 유틸을 활용한 머니 회전
    TweenUtil.TweenLocalRotation(moneyTrans,Quaternion.Euler(new Vector3(0f, 90f,0f)),false,_itemMoveTimeLimit);

    AudioManager.NullableInstance.PlaySFX(EAudioName.MoneyStackSound,true,false, 0.05f);
 
    while (Time.time < endSec) // Lerp() 함수와 AnimationCurve클래스를 활용한 머니 스택킹 애니메이션
    {
        var ratio = (Time.time - startSec) / _moneyMoveTimeLimit;
        moneyTrans.localPosition = Vector3.Lerp(moneyTrans.localPosition, targetPos , _moneyMoveCurve.Evaluate(ratio));
        moneyTrans.localPosition = moneyTrans.localPosition + Vector3.up * _moneyJumpCurve.Evaluate(ratio);
        yield return CoroutineUtil.WaitForFixedUpdate;
    }

    moneyTrans.localPosition = targetPos; // 타겟 포지션 고정

    if (doneCallback != null) // 마지막 돈 획득시 호출되는 donecallback
    {
        AudioManager.NullableInstance.ResetPitch(EAudioName.MoneyStackSound);
        _takeMoneyCoroutine = null;

        if (_isPlayerInMoneyStacker)
            _checkMoneyGenCoroutine = this.StartCoroutine(CoCheckMoneyGen());
        
        doneCallback.Invoke();
    }

    MoneyManager.UpdateCurrentMoney(Money.Price); //  MoneyManager 스태틱 클래스의 메서드를 통해 금액 업데이트 (내부에선 콜백을 사용하여 UI와 소통)
}
````

**MoneyStacker**[📜 : 스크립트 전문보기](https://github.com/iLovealan1/KIm-Dong-Joon-game-client-Portfolio/blob/main/PlayableGames_Scripts/OutletRush_Playable/MoneyObject/MoneyStacker.cs)<br>
### 코드

&nbsp;&nbsp;&nbsp;&nbsp;● GenerateMoney() : CoGenerateMoney() 머니 생성 코루틴을 _isOkToGen 부울 값을 이용해 제어합니다 <br>
&nbsp;&nbsp;&nbsp;&nbsp;● SetMoneyPos() : 돈의 생성 위치를 Transform배열과 childCount를 활용해 조정합니다. <br>
&nbsp;&nbsp;&nbsp;&nbsp;● GetMoneyStack() : IMoneyStackReturner의 메서드로 done Callback과 께 머니 Stack을 반환합니다. <br>

````
public void GenerateMoney(int amount) => this.StartCoroutine(CoGenerateMoney(amount));

private IEnumerator CoGenerateMoney(int amount)
{
    yield return CoroutineUtil.WaitUntil(() => {return _isOkToGen;});

    var count = Math.Round((float)amount / (float)Money.Price , 1) ;

    for (int i =0; i < count; i++)
    {
        var money = _moneyPool.GetMoney();
        _currMoneyStack.Push(money);
        SetMoneyPos(money);
    }
}

private void SetMoneyPos(Money money)
{
    Transform moneyTrans =  money.transform;
    Transform targetTrans = null;

    var minCount = 0f;
    for (int i = 0; i < _defaultPosArr.Length; i++)
    {
        var childCount = _defaultPosArr[i].childCount;

        if (childCount == 0)
        {
            targetTrans = _defaultPosArr[i];
            moneyTrans.parent = targetTrans;
            moneyTrans.localPosition = Vector3.zero;
            return;
        }

        if (minCount == 0)
        {
            minCount = childCount;
            targetTrans = _defaultPosArr[i];
        }

        if (minCount > childCount)
        {
            minCount = childCount;
            targetTrans = _defaultPosArr[i];
        }
    }

    moneyTrans.parent = targetTrans;
    moneyTrans.localRotation = Quaternion.identity;
    moneyTrans.localPosition = new Vector3(0, SPACINGY * minCount, 0);
}

public Stack<Money> GetMoneyStack(out System.Action doneCallback)
{
    doneCallback = () => {
        _isOkToGen = true;
        if (_onPlayerTakeMoney != null)
        {
            _onPlayerTakeMoney.Invoke(EGuideArrowState.DisplayShelf_Shoe2_Upgrade);
            _onPlayerTakeMoney = null;
        }
     };

    if (_currMoneyStack.Count == 0)
    {
        return null;         
    }
    else
    {
        _isOkToGen = false;
        return _currMoneyStack;
    }
}
````

[📑: 목차로](#목차)

---

# 🟢: Burger Please! Playable<br>[📂:폴더이동](https://github.com/iLovealan1/KIm-Dong-Joon-game-client-Portfolio/tree/main/Scripts/Field_Coin%26Items)


### 🔖: field_items

![GetCoin](https://github.com/iLovealan1/KIm-Dong-Joon-game-client-Portfolio/assets/124248265/b1a7ce3c-100e-4d93-a74c-1269e90e98cd)

### **이미지 설명(최상단부터)**
- 필드 코인 개별 획득

### **요약**
- ChestItemGenerator 클래스와 DropItem 클래스를 이용한 아이템 생성.

### **상세 내용**
**DropItem**[📜 : 스크립트 보기](https://github.com/iLovealan1/KIm-Dong-Joon-game-client-Portfolio/blob/main/Scripts/Field_Coin%26Items/DropItem.cs)<br>
&nbsp;&nbsp;&nbsp;&nbsp;● ChestItemGenerator 클래스의 메서드 팩토리 패턴으로 생성된 객체의 이름에 따라 switch문 과 if문을 통해 각각 다른 메서드를 호출합니다.<br>

###코드

    pirvate void test(){}


[📑: 목차로](#목차)

---


## 🟢: Burger Please! Playable 2<br>[📂:폴더이동](https://github.com/iLovealan1/KIm-Dong-Joon-game-client-Portfolio/tree/main/Scripts/Field_Coin%26Items)

### 🔖: field_items

![GetCoin](https://github.com/iLovealan1/KIm-Dong-Joon-game-client-Portfolio/assets/124248265/b1a7ce3c-100e-4d93-a74c-1269e90e98cd)

### **이미지 설명(최상단부터)**
- 필드 코인 개별 획득

### **요약**
- ChestItemGenerator 클래스와 DropItem 클래스를 이용한 아이템 생성.

### **상세 내용**
**DropItem**[📜 : 스크립트 보기](https://github.com/iLovealan1/KIm-Dong-Joon-game-client-Portfolio/blob/main/Scripts/Field_Coin%26Items/DropItem.cs)<br>
&nbsp;&nbsp;&nbsp;&nbsp;● ChestItemGenerator 클래스의 메서드 팩토리 패턴으로 생성된 객체의 이름에 따라 switch문 과 if문을 통해 각각 다른 메서드를 호출합니다.<br>

###코드

    pirvate void test(){}


[📑: 목차로](#목차)

---
